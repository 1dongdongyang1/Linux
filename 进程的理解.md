# 进程的理解

**目录**：

1. [什么是进程](#1.0)
2. [主要特征](#2.0)
3. [主要组成部分](#3.0)
4. [进程状态](#4.0)
5. [进程优先级](#5.0)

---

## 1.什么是进程<p id="1.0"></p>

**概念**：

+ 在操作系统中，**进程（Process）**是一个正在执行的程序实例。
+ 可以将进程理解为一个动态的实体，它不仅包括**静态的程序代码**，还包括程序执行过程中**涉及的所有信息**，如内存空间、文件描述符、CPU状态等。



> 管理的本质：先描述，再组织

为了方便管理进程，将进程的信息抽象出来，放在叫做**进程控制块（PCB）**的数据结构中。PCB是操作系统用来管理进程的核心数据结构，包含了进程的**所有重要信息**。即**进程=程序代码+PCB**。



> PCB的**组成部分**：
>
> + **进程标识符（PID）**：唯一标识进程的整数，用于区分不同的进程。
> + **进程状态**：表示进程当前的状态，如就绪、运行、阻塞、终止等。
> + **程序计数器（PC）**：指向下一个要执行的指令地址，操作系统通过它来恢复进程的执行。
> + **CPU寄存器状态**：包括各个 CPU 寄存器的当前值，以便在进程切换时能够恢复执行。
> + **内存管理信息**：包括指向进程地址空间的基址和限长，或其他内存管理结构的信息。
> + **调度信息**：进程的优先级、调度策略等，用于决定进程的执行顺序。
> + **进程间通信信息**：进程使用的信号量、消息队列、共享内存等，用于进程之间的通信和同步。
> + **I/O状态信息**：包含进程打开的文件描述符、网络连接等信息，帮助管理与 I/O 相关的操作。
> + **用户信息**：可能包括与用户相关的信息，如用户 ID 和组 ID，以确保安全性和访问控制。



## 2.主要特征<p id="2.0"></p>

1. **动态性**：进程是程序在操作系统中的一次执行过程，因此是动态的。进程从创建到执行、暂停、终止等，一直处于变化之中。

2. **独立性**：每个进程都有自己的私有地址空间和资源，彼此独立。一个进程的运行不应直接影响其他进程，操作系统通过隔离机制确保进程之间的独立性。

3. **并发性**： 在多任务操作系统中，可以同时运行多个进程。多个进程可以并发执行，在多核系统上可以真正实现并行，在单核系统上则是通过快速切换实现“并行”。

   > **并发**：任务可以交替进行，而不一定是同时
   >
   > **并行**：多个任务同时进行

4.  **资源管理**：进程需要操作系统分配的各种资源（如CPU时间、内存、文件句柄等）才能正常运行。操作系统通过进程来管理和分配这些资源。

5.  **生命周期**：每个进程从创建到退出经历一个完整的生命周期，包括创建、就绪、运行、等待（或阻塞）和终止等状态的转换。



## 3.主要组成部分<p id="3.0"></p>

1. **进程控制块（PCB）**：
   + 每个进程在操作系统中都有一个进程控制块（Process Control Block），它记录了进程的相关信息，如进程ID、进程状态、优先级、CPU寄存器状态、内存分配信息等。
   + PCB 是操作系统管理和调度进程的核心数据结构。
2. **地址空间**：每个进程有自己独立的地址空间，分为代码区、数据区、堆栈区等。
   + **代码区**：存储程序的执行代码。
   + **数据区**：存储全局变量和静态变量。
   + **堆区**：用于动态内存分配。
   + **栈区**：用于存储函数调用、局部变量、返回地址等。
3. **CPU状态**：进程在运行时，需要CPU寄存器、程序计数器等状态信息。操作系统会保存和恢复这些信息，以便在进程切换时能够正确恢复进程的执行状态。
4. **文件和资源**：进程可能会打开文件、使用网络连接等。操作系统为每个进程维护一个资源表，记录它使用的资源句柄。

> PCB中已经包含了**CPU状态**和**文件和资源**，也就是第3和第4点，而在描述进程的组成部分时再次提及它们，目的是强调它们在进程执行过程中的重要性。

## 4.进程状态<p id="4.0"></p>

进程在其生命周期中经历多个状态。以下是进程的主要状态及其描述：

1. **新建状态（New）**：进程正在被创建。此状态表示操作系统正在为新进程分配必要的资源，如内存、进程控制块等。
2. **就绪状态（Ready）**：进程已经获得了必要的资源，但尚未被调度到CPU上执行。在这个状态下，进程随时可以执行，只待调度器选择它。
3. **运行状态（Running）**：进程正在使用CPU执行指令。在这个状态下，进程被分配了CPU时间，并正在执行其代码。
4. **阻塞状态（Blocked / Waiting）**：进程因为等待某些事件（如I/O操作完成、资源可用等）而无法继续执行。在这个状态下，进程不能被调度到CPU上运行，直到所等待的事件发生。
5. **终止状态（Terminated）**：进程完成执行或由于异常情况退出。此状态下，进程的资源被释放，操作系统会更新其PCB以反映进程的终止。
6. **挂起状态（Suspended）**：有些操作系统会引入“挂起”状态，表示进程被暂时移出内存，处于不活跃状态。此状态可以分为：
   + **挂起就绪（Suspended Ready）**：进程被挂起，但可以被恢复到就绪状态。
   + **挂起阻塞（Suspended Blocked）**：进程因等待事件而被挂起。
7. **就绪挂起状态（Ready Suspended）**：进程虽然在就绪状态，但由于系统资源不足而被挂起。这时，进程不能立即运行，需等待资源可用。



上面的这些状态是站在所有操作系统的角度所谈的，下面将介绍**Linux操作系统**的进程状态。

```C
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};
```

这是Linux操作系统**kernel源代码**里对进程状态的定义：

+ `"R (running)"`: 任务正在运行或已准备好运行。
+ `"S (sleeping)"`: 任务处于睡眠状态，等待某个事件完成。
+ `"D (disk sleep)"`: 任务处于不可中断的睡眠状态，通常是在等待磁盘 I/O。
+ `"T (stopped)"`: 任务已停止，通常是由于信号或用户请求。
+ `"t (tracing stop)"`: 任务因跟踪而停止，通常是由**调试器**引起的。
+ `"X (dead)"`: 任务处于“死亡”状态，意味着已终止但资源尚未完全清理。
+ `"Z (zombie)"`: 任务是一个僵尸进程，已经终止但在等待父进程读取其退出状态。

在实际的操作系统中，**挂起**这一状态是**不可见的**，被操作系统藏起来，避免人为修改造成破坏。



**特殊的进程状态**

**僵尸进程**：是一种已经终止但尚未被**父进程**回收的进程。

> **父进程**（Parent Process）是指生成子进程的进程。每个进程在启动新的子进程时都会成为该子进程的父进程。

**产生过程**：

1. **子进程终止**：子进程完成任务并退出。
2. **进程状态保留**：操作系统保留子进程的进程 ID (PID) 和状态信息，直到父进程通过 `wait` 系列系统调用读取它。
3. **等待父进程回收**：在父进程读取子进程的状态前，子进程保持僵尸状态。此时，它已释放资源，但仍在进程表中占用一个位置。



**孤儿进程**：是指其父进程已经终止，但它本身仍在运行的进程。

**处理过程**：

1. **父进程终止**：孤儿进程的父进程意外退出或因故障而终止，导致子进程失去父进程。
2. **重新分配给 `init` 进程**：在 Unix 和 Linux 系统中，所有孤儿进程会被自动重新分配给 `init` 进程（通常 PID 为 1），该进程是所有进程的祖先。`init` 进程的职责之一是充当孤儿进程的新父进程。
3. **继续执行并回收**：孤儿进程在 `init` 进程的管理下继续执行，并在其结束时由 `init` 进程回收，避免产生僵尸进程。

## 5.进程优先级<p id="5.0"></p>

> 为什么会有优先级？
>
> + 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有**竞争属性**的。为了高效完成任务，更合理竞争相关资源，便具有了优先级。
>
> 怎么理解权限和优先级？
>
> + 权限是**能不能做**，优先级是**谁先做**

**进程优先级**是指操作系统用来决定进程获得 CPU 时间的相对重要性和顺序的数值指标。优先级高的进程有优先执行权利。配置进程优先权对多任务环境的Linux很有用，可以改善系统性能。

![Linux系统进程](D:\a.blog\Linux\picture\Linux系统进程.png)

上图是Linux操作系统的实时进程状态图，输入`ps -l`输出，简单解释下：

+ **F**（Flag）：进程的标志位，代表进程的某些属性。
+ **S**（State）：进程的状态
+ **UID**（User ID）：表示进程所有者的用户 ID。
+ **PID**（Process ID）：进程的唯一标识符。
+ **PPID**（Parent Process ID）：父进程的 ID。
+ **C**（CPU Usage）：进程的 CPU 使用率百分比。
+ **PRI**（Priority）：进程的优先级。
+ **NI**（Nice Value）：进程的 nice 值，影响优先级。
+ **ADDR**：内存地址。`-` 表示地址未被使用或不可用。
+ **SZ**（Size）：进程的内存占用大小，以页（page）为单位。
+ **WCHAN**（Waiting Channel）：如果进程在等待资源，这里会显示正在等待的内核函数。
+ **TTY**（Terminal）：进程关联的终端。两个进程都在 `pts/0` 上，这意味着它们是通过同一终端会话（伪终端）启动的。
+ **TIME**：进程使用的总 CPU 时间。
+ **CMD**（Command）：进程启动时的命令。

其中，有关进程优先级的是**PRI**和**NI**。

+ **PRI**是进程的优先级，其值越小优先级越高。
+ **NI**是人为可以修改的地方，**PRI(new)=PRI(old)+NI**，我们通过更改**NI值**来影响进程的优先级，其中**NI**的取值范围是[-20,19)。

> 如何修改**NI**值？
>
> 输入`top`->`r`->`进程的PID`->`NI值`
