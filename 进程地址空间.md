# 进程地址空间

**目录**

1. [什么是进程地址空间](#1.0)
2. [地址的理解](#2.0)
3. [进程地址空间的分区](#3.0)
4. [深度理解进程地址空间](#4.0)

---

## 1.什么是进程地址空间<p id="1.0"></p>

**引言**：

我们在学习C语言/C++时，当时为了方便我们理解和认识**数据在内存中的存储**，引入了**C/C++内存分布图**，即下图：

![C++内存分布](D:\a.blog\Linux\picture\C++内存分布.png)

我们将**内存分区**，分成了：栈区，堆区，数据段，代码段。不同的区域存储不同的数据，如栈区存储变量，`malloc`函数将空间开在堆区，全局变量和静态变量放在数据段，常量放在代码段等等。

这些在我们当时学的时候，觉得没有问题，但是，学习**冯诺依曼结构**，我们知道了程序在运行时，代码和数据都需要加载到内存中，那现在有一个问题，如果一个程序就把内存给全占了，操作系统还怎么运行？要知道操作系统在运行时也是需要被加载到内存中的。

---

**正文**：

为了解决上面的问题，**操作系统给每个进程都分配独立的虚拟内存区域**，而这个**虚拟内存区域**就是**进程地址空间**。

说简单点，因为进程地址空间的存在，**每个进程都认为自己是独享整个内存的**，但是实际上，操作系统会通过页表来将虚拟内存的地址映射到物理内存上。

**进程地址空间图示**：

![进程地址空间](D:\a.blog\Linux\picture\进程地址空间.png)

没错，以往我们学的**C/C++内存分布**其实是**进程地址空间**，它不属于语言范畴的学习，算作操作系统的。

## 2.地址的理解<p id="2.0"></p>

> 研究背景：32位平台

为什么内存会有地址？

+ 内存拥有地址是为了**定位和管理数据**。地址为内存中的每个存储单元提供了一个**唯一标识**，使得处理器能够精确地读取或写入数据。

为什么地址的范围是0~2^32?

+ 首先，地址的范围与平台的位数有关，32位平台地址最大是2^32，64位平台地址最大是2^64。
+ 在32位平台上，内存地址的长度是32位，即每个内存地址由32个二进制位组成。
+ 由于地址空间大小是 2^32 个不同的地址单元，因此最大可以支持 **4GB** 的内存（2^32=4,294,967,296 字节）。

## 3.进程地址空间的分区<p id="3.0"></p>

进程地址空间分区的功能，小羊已经写过相关的博客[点我](https://blog.csdn.net/2301_80030944/article/details/139510677)

这里，我们着重探讨的是进程地址空间**在底层是如何实现分区的**。

> 研究背景：kernel 2.6.32	

首先，在进程部分，我们知道，**进程=PCB+程序代码**，对于进程地址空间的记录，就被放在了**PCB**中。

而Linux在底层实现PCB时，用的是`task_struct`结构体，来保存数据，而进程地址空间的数据保存，则是用了`mm_struct`结构体

![Linux底层实现分区](D:\a.blog\Linux\picture\Linux底层实现分区.png)

没错，进程地址空间的分布就是**直接用相关分区的开头和结尾定义**下的，例如：

+ `start_code`是代码区的开始，`end_code`是代码区的结束。
+ `start_data`是数据区的开始，`end_data`是代码区的结束。

## 4.深度理解进程地址空间<p id="4.0"></p>

1. 为什么会存在进程地址空间？

   1. 如果让进程直接访问物理内存，如果进程非法越界了会非常不安全。
   2. 进程地址空间的存在，可以更方便进行进程和数据代码的耦合，保证了进程的**独立性**。
   3. 让进程和编译器都以统一的视角，看待进程对应的代码和数据各个区域，方便使用。

2. 只有OS会遵守虚拟地址空间的规则吗？

   + 不是，编译器也要遵守。编译器在编译时，就是按照虚拟地址空间的方式对代码进行编址。

3. 可执行程序在写完后放在磁盘上，此时没有被加载到内存里，可执行程序的内部是否存在地址？

   + 存在，程序在编译时，函数和变量就被编写了虚拟地址。

4. 当程序被加载到内存上后，就天然具有了物理地址，此时的程序就有了两套地址。

   

   

